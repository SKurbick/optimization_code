city = [['Екатеринбург', 'Москва'], ['Санкт-Петербург', 'Норильск'], ['Пермь', 'Астрахань']]
print(sum(city, []))# метод прибавляет список списков к пустому списку. не создаются дополнительные переменные
#вся работа в одну строку
#выводит данные списков в один список.

data = [
    [13, 25, 23, 34],
    [45, 32, 44, 47],
    [12, 33, 23, 95],
    [13, 53, 34, 35]
]
#дан список в котором нужно прибавить все цифры по диагонали (13, 32, 23, 35)


result = 0# переменная, к которой будут суммироваться все необходимые числа
index = 0# переменная с условным индексом
for row in data:# цикл списков внутри списка
    result += row[index] #прибавляем к условному числу(которое будет с каждым циклом увеличиваться) дополнительное число
                            #с заданным индексом
    index += 1 # смещает индекс для числа в словаре в уже для следующего цикла
print(result)# вывод
#ниже аналогичная логика прописана в одну строку
print(sum([row[index] for index, row in enumerate(data)]))
#используется больший арсенал синтаксиса пайтон.
# Основа прописанная в квадратных скобках это условный инвертированный цикл. Подробнее "list comprehension"
#То есть сам цикл уже можно обозначить в одну строку(print([row for row in date])выведет каждый отдельный список)
# к переменной row мы закрепили переменную index к какому индексу(числу) в списке обращаться
#enumerate в свою очередь работает как счетчик, в виде ключ:значение, где ключ с каждым циклом возрастает на один
#начиная с нуля, в нашем случае работает как индекс а значение у нас число в каждом списке. Благодаря enumerate
#мы можем делить числа по диагонали
#sum уже суммирует все значения по диагонали в цикле к которым мы обращались.