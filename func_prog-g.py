from functools import reduce

prices_by_categories = [[100, 200, 400, 600], [200, 500], [100, 200, 100, 100], [800, 900]]
# нужно посчитать среднее ариф-е значение каждого отдельного списка внутри списка
# оператор lambda создает одноразовую функцию
# благодаря мап мы проходимся по каждому списку/элементу в prices_by_categories
print(list(map(lambda elem: sum(elem) / len(elem), prices_by_categories)))
# [325.0, 350.0, 125.0, 850.0]

# нужно перевести все строки в числовое значение, то есть из str делать int
old_list = ['1', '2', '3', '4', '5', '6', '7']
new_list = list(map(int, old_list))  # всего два аргумента, 1-это функция, 2-элемент с которым работает программа)


# [1, 2, 3, 4, 5, 6, 7]

# в первом аргументе может быть любая именная функция, либо созданная пользователем
# условно
def func(elems):
    return elems + 1


nums = list(map(func, new_list))  # как с int в первом случае мы не указываем аргументы в функцию, для map все очевидно
# еще для чтения мы используем метод list
# во втором случае мы использовали переменную с первой функции с переделанным списком на int значения и прибавили к каждому
# значению +1
print(nums)  # [2, 3, 4, 5, 6, 7, 8]
#######################################################################################################################
geo_logs = [
    {'visit1': ['Москва', 'Россия']},
    {'visit2': ['Дели', 'Индия']},
    {'visit3': ['Владимир', 'Россия']},
    {'visit4': ['Лиссабон', 'Португалия']},
    {'visit5': ['Париж', 'Франция']},
    {'visit7': ['Тула', 'Россия']},
    {'visit9': ['Курск', 'Россия']},
    {'visit10': ['Архангельск', 'Россия']}
]
# нужно вывести все визиты с Россией

res = list(filter(lambda log: 'Россия' in list(log.values())[0], geo_logs))
# фукция высшего порядка filter 'фильтрует' значения переданные в функции и выводит результат в котором хранятся эти значения
# в первом аргумента задается функция для проверки, во второй: объект в котором будут проверенны значения

########################################################################################################################
district_3 = {'flat_4': 6500, 'flat_5': 7000, 'flat_6': 6000}

print(dict(sorted(district_3.items(), key=lambda item: item[1])))
# {'flat_6': 6000, 'flat_4': 6500, 'flat_5': 7000}

# функция сортирует заданные значения
# в sorted в первом аргументе мы задаем объект для сортировки
# во втором аргументе, в параметре key указываем функцию которая будет адресована на значения цифр в словаре
# весь отсортированный вывод преобразуем обратно в словарь
########################################################################################################################
# модуль reduce импортированный из библеотки functools устроен так, что производит действие над каждый последующим элементом
# изменяя при этом предыдущий элемент. То есть в нашем примере он возводит 2 в степень 3, полученный ответ возводит уже в 4
# и так до окончания последнего элемента
elements = reduce(lambda a, b: a ** b, [2, 3, 4, 5, 6])
print(
    elements)  # 2348542582773833227889480596789337027375682548908319870707290971532209025114608443463698998384768703031934976

some_list = ['2018-01-01', 'yandex', 'cpc', 100]
upd_dictionary = reduce(lambda last_el, prev_el: {prev_el: last_el}, reversed(some_list))
#не арифметический пример
print(upd_dictionary)#{'2018-01-01': {'yandex': {'cpc': 100}}}
